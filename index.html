<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>OreStellar</title>

<!-- Google Font: Orbitron -->
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&display=swap" rel="stylesheet">

<!-- LZString for URL compression (share) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>

<style>
/* ================== BASE ================== */
:root{
  --neon: #ffffff;
  --bg: #000;
  --panel: rgba(20,20,20,0.92);
  --mono: 'Share Tech Mono', monospace;
  --orbitron: 'Orbitron', sans-serif;
}
html,body{margin:0;padding:0;height:100%;background:var(--bg);font-family:monospace;color:#fff;overflow:hidden;}
/* star canvas sits at z=0 and pointer-events none so overlay works */
canvas#starfield {
  position: fixed;
  top: 0;
  left: 0;
  z-index: 0;
  pointer-events: none;
}

/* ================== LAYOUT ================== */
.container-wrapper{
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  min-height:100vh;
  gap:20px;
  padding:20px;
  z-index:2;
  position:relative;
}

/* ================== LOGO ================== */
#myHeader{
  display:flex;
  justify-content:center;
  align-items:center;
  flex-direction:column;
  text-align:center;
  width:100%;
  max-width:650px;
  margin-bottom:30px;
  cursor:pointer;
  z-index:3;
}
#logoText{display:inline;font-family:var(--orbitron);font-weight:700;font-size:4.5rem;letter-spacing:0;color:rgba(255,255,255,0.1);transform:skewX(-8deg);}
#logoText span{display:inline;color:rgba(255,255,255,0.1);text-shadow:none;}

@keyframes softGlow {
  0%,100% { text-shadow: 0 0 5px #fff; color: rgba(255,255,255,0.75); }
  50% { text-shadow: 0 0 15px #fff; color: rgba(255,255,255,1); }
}

@keyframes flickerRapid {
  0%,20%,40%,60%,80%,100% { color: rgba(255,255,255,1); text-shadow: 0 0 10px #fff; }
  10%,30%,50%,70%,90% { color: rgba(255,255,255,0.1); text-shadow: none; }
}

@keyframes flickerQuick {
  0%,50%,100% { color: rgba(255,255,255,0.1); text-shadow: none; }
  25%,75% { color: rgba(255,255,255,1); text-shadow: 0 0 10px #fff; }
}



/* ================== MAIN PANEL ================== */
.main-container{
  width:650px;
  max-width:92%;
  padding:30px;
  display:flex;
  flex-direction:column;
  justify-content:center;
  align-items:center;
  background-color:var(--panel);
  border-radius:15px;
  z-index:2;
  box-shadow:0 6px 24px rgba(0,0,0,0.6);
}

/* header above textarea */
#inventoryHeader{
  font-family:var(--orbitron);
  font-weight:700;
  color:#fff;
  text-shadow:0 0 8px #fff,0 0 16px #fff,0 0 24px var(--neon);
  margin:0 0 12px 0;
  padding-bottom:6px;
}

/* textarea styling â€” filler smaller & greyed */
textarea#message{
  display:block;
  margin:0 auto;
  width:92%;
  font-size:14px;
  color:#bfbfbf; /* filler color until user edits */
  background-color: rgba(17,17,17,0.97);
  padding:14px;
  border-radius:10px;
  resize:vertical;
  border:1px solid #333;
  text-align:left;
  font-family:var(--mono);
  box-shadow: inset 0 0 6px #111;
  line-height:1.35;
  min-height:130px;
}
textarea#message.small-filler { font-size:13px; color:#9a9a9a; } /* smaller, greyed filler */

textarea#message:focus{
  outline:none;
  border-color:#fff;
  box-shadow:inset 0 0 15px #fff,0 0 25px #fff;
  color:#e6e6e6; /* actual typing color */
}

/* ================== BUTTONS ================== */
.actionButton{
  margin-top:15px;
  background:linear-gradient(145deg,#161616,#242424);
  color:#fff;
  border:2px solid #ccc;
  border-radius:10px;
  padding:12px 26px;
  font-weight:bold;
  font-family:var(--orbitron);
  cursor:pointer;
  position:relative;
  overflow:hidden;
  text-shadow:0 0 2px #fff;
  box-shadow:0 0 6px #ffffff33,0 0 12px #ffffff11 inset;
  transition:all 0.25s ease;
}
.actionButton:disabled{opacity:0.45;cursor:not-allowed;}

/* ================== CONTRACT / SUMMARY / PRICELIST ================== */
.contracts-wrapper{display:flex;justify-content:center;align-items:flex-start;gap:15px;flex-wrap:wrap;width:100%;}

/* contract images */
.total-cost-container{
  width:630px;height:418px;background-size:contain;background-position:center;background-repeat:no-repeat;position:relative;border-radius:15px;box-shadow:0 4px 8px rgba(0,0,0,0.5);display:none;
}
#leftContainer{background-image:url('https://raw.githubusercontent.com/OreStellar/Orestellar.github.io/refs/heads/main/images/Contract1.png');display:none;}
#totalCostContainer{background-image:url('https://raw.githubusercontent.com/OreStellar/Orestellar.github.io/refs/heads/main/images/Contract2.png');display:none;position:relative;}
#totalCostText{position:absolute;top:18px;right:20px;color:var(--neon);font-family:var(--mono);font-weight:bold;font-size:18px;text-shadow:0 0 6px var(--neon),0 0 12px var(--neon);cursor:pointer;}

/* price tab: Z with short horizontal line */
#priceTab{
  position:fixed;top:22vh;right:18px;width:48px;height:48px;border-radius:10px;background:var(--neon);color:#000;display:flex;justify-content:center;align-items:center;font-weight:700;font-size:20px;cursor:pointer;box-shadow:0 0 12px var(--neon),0 0 30px var(--neon) inset;z-index:30;transition:transform 0.18s ease;
  font-family:var(--orbitron);
}
#priceTab::before{ content:"\005A"; position:absolute; top:7px; font-size:28px; }
#priceTab::after{ content:""; position:absolute; top:22px; width:18px; height:2px; background:#000; }

/* floating price list */
#priceListContainer{
  position:fixed;top:18vh;right:78px;width:360px;max-height:72vh;overflow-y:auto;background:rgba(0,0,0,0.95);border:1px solid var(--neon);padding:12px;border-radius:10px;display:none;box-shadow:0 0 22px var(--neon);z-index:29;font-family:var(--mono);color:var(--neon);
}
#priceListContainer table{width:100%;border-collapse:collapse;}
#priceListContainer th,#priceListContainer td{padding:6px 8px;border-bottom:1px solid rgba(0,255,0,0.06);font-size:13px;text-align:left;}
#priceListContainer th{font-weight:700;color:var(--neon);}

/* summary container */
.summary-container{
  display:none;flex-direction:column;align-items:stretch;justify-content:flex-start;font-family:var(--mono);font-size:14px;line-height:1.4;color:var(--neon);background:rgba(0,10,0,0.95);border:2px solid var(--neon);border-radius:12px;padding:16px 20px;min-width:420px;max-width:520px;max-height:72vh;overflow-y:auto;backdrop-filter:blur(6px);box-shadow:0 0 18px rgba(0,255,0,0.18);z-index:3;
}
.summary-container::-webkit-scrollbar{width:8px;}
.summary-container::-webkit-scrollbar-thumb{background:var(--neon);border-radius:6px;box-shadow:0 0 10px var(--neon);}

.summary-table{width:100%;border-collapse:collapse;table-layout:fixed;}
.summary-table th, .summary-table td {padding:8px 10px;border-bottom:1px solid rgba(0,255,0,0.03);font-size:13px;white-space:nowrap;}
.summary-table th:nth-child(1), .summary-table td:nth-child(1){text-align:left;}
/* align numeric columns to the right */
.summary-table td.price, .summary-table td.quantity, .summary-table td.total-column {text-align:right;font-variant-numeric:tabular-nums;}
/* header numeric alignment: make headers match columns (right) */
.summary-table th{ text-align:right; color:var(--neon); text-shadow:0 0 6px var(--neon); border-bottom:1px solid rgba(0,255,0,0.1); }
.summary-table th:first-child{ text-align:left; } /* Name header left */
.summary-table tr.unrecognized td {color:#ff6666;font-weight:700;text-shadow:0 0 8px #ff5555;}
.summary-total td{border-top:2px solid rgba(0,255,0,0.18);font-weight:700;padding-top:10px; text-align:right;}

/* small responsive tweaks */
@media (max-width:720px){
  #priceListContainer{ right:10px; width:320px; max-height:50vh; }
  .main-container{padding:20px;}
  #logoText{font-size:3.2rem;}
}


</style>
</head>
<body data-show-inventory="true">

<!-- MAIN LAYOUT -->
<canvas id="starfield"></canvas>

<div class="container-wrapper" id="appRoot">
  <header id="myHeader" title="Return home">
    <h1 id="logoText"><span id="ore">Ore</span><span id="stellar">Stellar</span></h1>
  </header>

  <div class="main-container" id="inventoryContainer" role="region">
    <h3 id="inventoryHeader">Paste Your Inventory Below</h3>

    <!-- initial filler text is greyed and smaller -->
    <textarea id="message" class="small-filler" rows="8" >
Compressed Ytirium	1304752
Compressed Gneiss	166047
Obsidian Ochre	8603
Eifyrium	8242
Compressed Dark Ochre	5086
Compressed Jet Ochre	3750
Compressed Prize Mordunium	998781
Pellucid Crokite	2912
Compressed Ducinium	4985
    </textarea>

    <button id="submitButton" class="actionButton" disabled>Submit</button>
  </div>

  <div class="contracts-wrapper">
    <div id="leftContainer" class="total-cost-container"></div>
    <div id="summaryContainer" class="summary-container"></div>
    <div id="totalCostContainer" class="total-cost-container">
      <div id="totalCostText">0 ISK</div>
    </div>
  </div>
<div id="priceTab" title="Open price list" role="button"></div>
<div id="priceListContainer"></div>

  <button id="shareButton" class="actionButton" style="display:none;margin-top:14px;">Share Summary</button>
</div>

<script>
// Main storage
let priceList = {};
let canonicalNames = {};
let groupedPriceMap = {};
let oreEntries = [];

const logoText = document.getElementById('logoText');
const ore = document.getElementById('ore');
const stellar = document.getElementById('stellar');
/* ====================== STARFIELD ====================== */
const canvas = document.getElementById('starfield');
const ctx = canvas.getContext('2d');

let stars = [];
const clusterCount = 25; // your cluster count

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}

function createStars() {
  stars = [];
  const centers = [];
  for (let i = 0; i < clusterCount; i++) {
    centers.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height });
  }

  const total = Math.max(500, Math.floor(canvas.width * canvas.height / 1000));
  for (let i = 0; i < total; i++) {
    let x, y;
    if (Math.random() < 0.6) {
      const c = centers[Math.floor(Math.random() * centers.length)];
      const r = Math.random() * 140;
      const a = Math.random() * Math.PI * 2;
      x = c.x + r * Math.cos(a);
      y = c.y + r * Math.sin(a);
    } else {
      x = Math.random() * canvas.width;
      y = Math.random() * canvas.height;
    }

    const r = Math.random();
    let color = '#ffffff';
    if (r < 0.005) color = '#ff0000';
    else if (r < 0.025) color = '#ffb6c1';
    else if (r < 0.055) color = '#ffff99';

    stars.push({
      x, y,
      size: Math.random() * 1.6 + 0.2,
      color,
      baseAlpha: 0.7 + Math.random() * 0.25,
      isBright: false,
      brightStart: 0,
      brightEnd: 0
    });
  }
}

// draw stars
function drawStars() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  const now = performance.now();
  for (const s of stars) {
    let alpha = s.baseAlpha;
    if (s.isBright && now >= s.brightStart && now <= s.brightEnd) {
      alpha = 1;
    }
    ctx.globalAlpha = alpha;
    ctx.fillStyle = s.color;
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

// animate stars (twinkle)
function animateStars() {
  const now = performance.now();
  for (const s of stars) {
    if (Math.random() < 0.001 && !s.isBright) {
      s.isBright = true;
      s.brightStart = now;
      s.brightEnd = now + 1500 + Math.random() * 3000; // twinkle duration
    } else if (s.isBright && now > s.brightEnd) {
      s.isBright = false;
    }
  }
  drawStars();
  requestAnimationFrame(animateStars);
}

// initial setup
window.addEventListener('load', () => {
  resizeCanvas();
  createStars();
  drawStars();
  animateStars(); // start twinkle loop
});

// handle resizing
window.addEventListener('resize', () => {
  resizeCanvas();
  createStars();
  drawStars();
});


/* ====================== LOGO FLICKER SEQUENCE ====================== */
/* single setLogoState used by flicker sequence */
function setLogoState(color, shadow) {
  ore.style.color = color;
  stellar.style.color = color;
  ore.style.textShadow = shadow || 'none';
  stellar.style.textShadow = shadow || 'none';
  // also apply to the grouped logoText to ensure consistent look
  logoText.style.color = color;
  logoText.style.textShadow = shadow || 'none';
}

/* Clicking the header resets to base view */
document.getElementById('myHeader').addEventListener('click', () => {
  window.location.href = window.location.origin + window.location.pathname;
});

function flickerLogo() {
  const steps = [
    // 1. Initial dim (1.2s)
    { color: 'rgba(220,220,220,0.15)', shadow: 'none', delay: 0 },

    // 2. First flicker (60ms)
    { color: '#dcdcdc', shadow: '0 0 10px #bfbfbf, 0 0 18px #bfbfbf', delay: 1200 },
    { color: 'rgba(220,220,220,0.15)', shadow: 'none', delay: 1260 },

    // 3. Short dim (0.3s)
    { color: 'rgba(220,220,220,0.15)', shadow: 'none', delay: 1560 },

    // 4. Second flicker (60ms)
    { color: '#dcdcdc', shadow: '0 0 10px #bfbfbf, 0 0 18px #bfbfbf', delay: 1560 },
    { color: 'rgba(220,220,220,0.15)', shadow: 'none', delay: 1620 },

    // 5. Dim for 0.9s
    { color: 'rgba(220,220,220,0.15)', shadow: 'none', delay: 1620 },
    // 6. Final flash (40ms)
    { color: '#dcdcdc', shadow: '0 0 12px #bfbfbf, 0 0 24px #bfbfbf', delay: 2520 },
    { color: 'rgba(220,220,220,0.15)', shadow: 'none', delay: 2560 },
  ];

  steps.forEach(step => {
    setTimeout(() => {
      ore.style.color = step.color;
      stellar.style.color = step.color;
      logoText.style.color = step.color;
      ore.style.textShadow = step.shadow;
      stellar.style.textShadow = step.shadow;
      logoText.style.textShadow = step.shadow;
    }, step.delay);
  });

  // 7. Begin steady glow forever
  setTimeout(() => {
    const glowAnim = 'softGlow 6s infinite';
    logoText.style.animation = glowAnim;
    ore.style.animation = glowAnim;
    stellar.style.animation = glowAnim;
  }, 2560); // after last dim
}

    const CSV_URL = 'https://raw.githubusercontent.com/OreStellar/Orestellar.github.io/main/data/prices.csv';

async function fetchPrices() {
  try {
    const res = await fetch(CSV_URL);
    const text = await res.text();
    const lines = text.split(/\r?\n/).map(l => l.trim()).filter(l => l);
    if (!lines.length) throw new Error("CSV empty");

    const header = lines[0].split(',').map(h => h.trim());
    let suggested150Idx = header.findIndex(h => h.includes('150'));
    if (suggested150Idx < 0) suggested150Idx = header.findIndex(h => h.toLowerCase().includes('suggested buy price'));
    const headerHas150 = suggested150Idx >= 0;

    priceList = {};
    canonicalNames = {};

    lines.slice(1).forEach(line => {
      const cols = splitCsvLine(line);
      while (cols.length < header.length) cols.push('');
      const name = cols[0].trim();
      if (!name) return;

      if (suggested150Idx < 0 || suggested150Idx >= cols.length) return;

      const suggestedRaw = cols[suggested150Idx]?.trim() || '';
      const suggested = parseFloat(suggestedRaw);
      if (!isFinite(suggested)) return;

      const normalized = normalizeName(name);
      priceList[normalized] = { csvValue: suggested, headerHas150 };
      canonicalNames[normalized] = name;
    });

    // <--- ADD THIS: populate oreEntries
    oreEntries = Object.keys(priceList).map(key => ({ key }));

    buildPriceGrouping();
    fillPriceList();

  } catch (err) {
    console.error('fetchPrices error', err);
  }
}



/* Helper: split CSV line while keeping quoted commas intact */
function splitCsvLine(line) {
  const out = [];
  let cur = '', inQuotes = false;

  for (let i = 0; i < line.length; i++) {
    const ch = line[i];
    if (ch === '"') { inQuotes = !inQuotes; continue; }
    if (ch === ',' && !inQuotes) {
      out.push(cur);
      cur = '';
      continue;
    }
    cur += ch;
  }
  out.push(cur); // push last value
  return out;
}

/* safe parse for numbers with commas and currency characters */
function parseNumberSafe(str){
  if(str === undefined || str === null) return NaN;
  const s = String(str).replace(/[^\d.\-]/g,'').trim();
  if(s === '') return NaN;
  const n = parseFloat(s);
  return isFinite(n) ? n : NaN;
}

/* normalize names for keys: lowercase, single spaces, trim */
function normalizeName(name){
  return (name || '').toString().toLowerCase().replace(/\s+/g,' ').trim();
}
function roundDownFlexible(n) {
  if (n >= 1000) return Math.floor(n / 100) * 100;
  if (n >= 100)  return Math.floor(n / 10) * 10;
  if (n >= 10)   return Math.floor(n / 10) * 10;
  if (n >= 1)    return Math.floor(n);
  if (n > 0)     return Math.floor(n * 1) / 1;
  return n;
}

/* ====================== PRICE GROUPING (for the floating list) ====================== */
function cleanName(name){
  return name.replace(/^Compressed\s+/i, '').trim();
}

function buildPriceGrouping() {
  groupedPriceMap = {}; // fresh map

  // Build a set of normalized variant names
  const allVariants = new Set();
  Object.values(oreVariantMap).forEach(variants => {
    variants.forEach(v => allVariants.add(normalizeName(v)));
  });

  // Only include canonical names that are NOT variants as candidate bases
  const candidateBases = Object.values(canonicalNames)
    .map(n => n.replace(/compressed\s+/i,'').trim())
    .filter(n => !allVariants.has(normalizeName(n)));

  Object.keys(canonicalNames).forEach(normKey => {
    const rawName = canonicalNames[normKey];
    if (!rawName) return;

    // Clean the name (remove "Compressed")
    const display = rawName.replace(/compressed\s+/i,'').trim();
    const lower = normalizeName(display);

    // Determine the base
    let chosenBase = null;

    // If it's a variant, map to its base
    const normalizedDisplay = normalizeName(display);
    if (variantToBase[normalizedDisplay]) {
      // variant â†’ normalized base â†’ find canonical display name
      const baseNormalized = variantToBase[normalizedDisplay];
      chosenBase = Object.values(canonicalNames).find(n => normalizeName(n) === baseNormalized) || display;
    } else {
      // If display is a candidate base, use it
      if (candidateBases.includes(display)) {
        chosenBase = display;
      } else {
        // fallback: use itself
        chosenBase = display;
      }
    }

    // Grab price
    const entry = priceList[normKey];
    if (!entry) return;
    const priceToShow = entry.csvValue;

    // Ensure parent group exists
    if (!groupedPriceMap[chosenBase]) groupedPriceMap[chosenBase] = [];

    // Deduplicate variants
    const existingNames = groupedPriceMap[chosenBase].map(v => normalizeName(v.name));
    if (!existingNames.includes(normalizedDisplay)) {
      groupedPriceMap[chosenBase].push({ name: display, price: priceToShow });
    }
  });
}

const messageBox = document.getElementById('message');
const submitButton = document.getElementById('submitButton');
let userHasEdited = false;

// --- INITIAL SETUP ---
// If value is empty, show small-filler style
if (!messageBox.value.trim()) {
  messageBox.classList.add('small-filler');
  messageBox.style.color = '#bfbfbf';
  submitButton.disabled = true;
} else {
  // If textarea has pre-filled text, assume it's user content
  messageBox.classList.remove('small-filler');
  messageBox.style.color = '#e6e6e6';
  userHasEdited = true;
  submitButton.disabled = false;
}

// --- ON FOCUS --- 
messageBox.addEventListener('focus', () => {
  if (messageBox.classList.contains('small-filler')) {
    messageBox.value = '';
    messageBox.classList.remove('small-filler');
    messageBox.style.color = '#e6e6e6';
    userHasEdited = true;
    submitButton.disabled = true; // still disabled until user types
  }
});

// --- ON INPUT ---
messageBox.addEventListener('input', () => {
  const txt = messageBox.value.trim();
  // mark edited if user has typed anything
  if (txt.length > 0) userHasEdited = true;
  // enable submit only if edited and non-empty
  submitButton.disabled = !(userHasEdited && txt.length > 0);
});

// --- ON BLUR ---
messageBox.addEventListener('blur', () => {
  if (!messageBox.value.trim()) {
    messageBox.classList.add('small-filler');
    messageBox.style.color = '#bfbfbf';
    userHasEdited = false;
    submitButton.disabled = true;
  }
});

/* ====================== PARSING INVENTORY & SUMMARY ====================== */
function parseInventoryText(text){
  const lines = text.split(/\r?\n/).map(l => l.trim()).filter(l => l !== '');
  const result = [];

  for(const rawLine of lines){
    // remove 'compressed' prefix for matching but keep display
    const lineNoCompressed = rawLine.replace(/compressed\s+/i, '').trim();
    const lowerLine = lineNoCompressed.toLowerCase();

    // find best matching ore entry (oreEntries are normalized keys)
    let foundKey = null;
    for(const entry of oreEntries){
      const key = entry.key; // normalized key
      const re = new RegExp('\\b' + escapeRegex(key) + '\\b','i');
      if(re.test(lowerLine)){
        foundKey = key;
        break;
      }
    }

    // extract quantity (first integer)
    let qty = 0;
    const qtyMatch = rawLine.match(/([\d,]+)/);
    if(qtyMatch){
      qty = parseInt(qtyMatch[1].replace(/,/g,''),10) || 0;
    }
if (foundKey) {
  const canonical = canonicalNames[foundKey] || foundKey;
  const priceEntry = priceList[foundKey];
  if (priceEntry) {
    // Use CSV value directly
    const perUnit = priceEntry.csvValue;
    const total = +(perUnit * qty);
    result.push({ name: canonical, qty, price: perUnit, total, unrecognized: false });
  } else {
    result.push({ name: canonical, qty, price: 0, total: 0, unrecognized: false });
  }
} else {
  // not found: include as unrecognized with original display trimmed
  const guessName = (lineNoCompressed.split(/\s+/).slice(0, 4).join(' ')).trim();
  result.push({ name: guessName, qty, price: 0, total: 0, unrecognized: true });
}

  } // end lines

  return result; // <- closes function
}

/* RENDER SUMMARY: produce table with headers that align with columns */
const summaryContainer = document.getElementById('summaryContainer');

function renderSummary(parsedItems){
  // compute grand total
  let grandTotal = 0;
  parsedItems.forEach(it => { grandTotal += (it.total || 0); });

  // Build table
  let html = '<table class="summary-table" role="table"><thead><tr>' +
    '<th>Name</th>' +
    '<th>Price</th>' +  // show price (right aligned)
    '<th>Quantity</th>' +
    '<th>Total</th>' +
    '</tr></thead><tbody>';

 parsedItems.forEach(it => {
  if(it.unrecognized){
    const truncated = (it.name || '').slice(0,28) + (it.name && it.name.length > 28 ? 'â€¦' : '');
    html += `<tr class="unrecognized"><td>${escapeHtml(truncated)}</td><td class="price">---</td><td class="quantity">---</td><td class="total-column">Unrecognized</td></tr>`;
  } else {
    const roundedPrice = roundDownFlexible(it.price);
    const roundedTotal = roundDownFlexible(it.total);
    
    html += `<tr><td>${escapeHtml(it.name)}</td>` +
            `<td class="price">${formatNumberDecimal(roundedPrice)}</td>` +
            `<td class="quantity">${formatNumberInteger(it.qty)}</td>` +
            `<td class="total-column">${formatNumberDecimal(roundedTotal)}</td></tr>`;
  }
});


  html += `<tr class="summary-total"><td colspan="3" style="text-align:left">Total</td><td id="summaryTotal">${formatNumberDecimal(grandTotal)}</td></tr>`;
  html += '</tbody></table>';

  summaryContainer.innerHTML = html;
  summaryContainer.style.display = 'flex';

  // show contract containers
  document.getElementById('leftContainer').style.display = 'block';
  document.getElementById('totalCostContainer').style.display = 'flex';
  document.getElementById('shareButton').style.display = 'inline-block';

  // update top-right contract total copyable
  const totalText = document.getElementById('totalCostText');
  totalText.innerText = formatNumberDecimal(grandTotal) + ' ISK';
  makeCopyable(totalText);

  // make the summary total copyable
  const sumEl = document.getElementById('summaryTotal');
  if(sumEl) makeCopyable(sumEl);

  attachSorting(summaryContainer);
}

/* helpers for number formatting */
function formatNumberInteger(n){
  if(n === null || n === undefined) return '-';
  return (typeof n === 'number' ? Math.round(n) : n).toLocaleString();
}
function formatNumberDecimal(n){
  if(n === null || n === undefined) return '-';
  if(typeof n !== 'number') return String(n);
  // show no decimals when integer, else two decimals
  if(Math.abs(Math.round(n) - n) < 0.005) return Math.round(n).toLocaleString();
  return n.toFixed(2).toLocaleString();
}

function makeCopyable(el){
  el.style.cursor = 'pointer';
  el.addEventListener('click', async ()=>{
    try {
      const text = el.innerText.replace(/[^\d\.\,]/g,'');
      await navigator.clipboard.writeText(text);
      const orig = el.innerText;
      el.innerText = 'Copied';
      setTimeout(()=> el.innerText = orig, 1200);
    } catch(e){
      // ignore
    }
  });
}

/* safe escape for HTML */
function escapeHtml(s){
  if(s===null || s===undefined) return '';
  return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
}

/* ====================== SORTING FOR SUMMARY ====================== */
function attachSorting(container){
  const table = container.querySelector('table');
  if(!table) return;
  const headers = table.querySelectorAll('th');
  headers.forEach((header, index) => {
    header.style.cursor = 'pointer';
    header.addEventListener('click', ()=>{
      const tbody = table.querySelector('tbody');
      const rows = Array.from(tbody.querySelectorAll('tr')).filter(r => !r.classList.contains('summary-total'));
      const totalRow = tbody.querySelector('.summary-total');
      const ascending = !header.classList.contains('sorted-asc');
      headers.forEach(h=>h.classList.remove('sorted','sorted-asc','sorted-desc'));
      header.classList.add('sorted');
      header.classList.toggle('sorted-asc', ascending);
      header.classList.toggle('sorted-desc', !ascending);

      rows.sort((a,b)=>{
        // unrecognized to bottom
        if(a.classList.contains('unrecognized') && !b.classList.contains('unrecognized')) return 1;
        if(b.classList.contains('unrecognized') && !a.classList.contains('unrecognized')) return -1;

        if(index === 0){
          // name column: alphabetical
          return ascending ? a.children[index].innerText.localeCompare(b.children[index].innerText)
                           : b.children[index].innerText.localeCompare(a.children[index].innerText);
        } else {
          // numeric columns
          const A = parseFloat(a.children[index].innerText.replace(/[^\d.\-]/g,'')) || 0;
          const B = parseFloat(b.children[index].innerText.replace(/[^\d.\-]/g,'')) || 0;
          return ascending ? A - B : B - A;
        }
      });

      rows.forEach(r => tbody.appendChild(r));
      if(totalRow) tbody.appendChild(totalRow);
    });
  });
}

/* ====================== SUBMIT / SHARE LOGIC ====================== */
const shareButton = document.getElementById('shareButton');

submitButton.addEventListener('click', ()=>{
  // double-check we have user content
  const txt = messageBox.value.trim();
  if(!txt) return;
  const parsed = parseInventoryText(txt);
  renderSummary(parsed);
  window.scrollTo({ top: 0, behavior:'smooth'});
  // HIDE INVENTORY AND SUBMIT
  document.getElementById('inventoryContainer').style.display = 'none';
  submitButton.style.display = 'none';
});

shareButton.addEventListener('click', async ()=>{
  const msg = messageBox.value.trim();
  if(!msg) return;
  const compressed = LZString.compressToEncodedURIComponent(msg);
  const url = `${location.origin}${location.pathname}?s=${compressed}`;
  try {
    await navigator.clipboard.writeText(url);
    const orig = shareButton.innerText;
    shareButton.innerText = 'Copied';
    setTimeout(()=> shareButton.innerText = orig, 1400);
  } catch(e){
    alert('Failed to copy URL.');
  }
});
/* ====================== PRICES & VARIANTS ====================== */

const RAW_PRICE_COL = 10;

// Map base ores to their variants
const oreVariantMap = {
  "Dark Ochre": [
    "Obsidian Ochre",
    "Onyx Ochre",
    "Jet Ochre",
  ]
};

// Build reverse map (variant â†’ base)
const variantToBase = {};
for (const [base, variants] of Object.entries(oreVariantMap)) {
  for (const variant of variants) {
    variantToBase[normalizeName(variant)] = normalizeName(base);
  }
}
// Price list toggle
const priceTab = document.getElementById('priceTab');
const priceListContainer = document.getElementById('priceListContainer');

priceTab.addEventListener('click', () => {
  if (priceListContainer.style.display !== 'block') {
    // rebuild price list if empty
    if (!Object.keys(groupedPriceMap).length) {
      buildPriceGrouping();
      fillPriceList();
    }
    priceListContainer.style.display = 'block';
  } else {
    priceListContainer.style.display = 'none';
  }
});

/* ====================== AUTO LOAD ====================== */
window.addEventListener('load', async () => {
    // fetch prices first
    await fetchPrices();

    // optionally start logo flicker
    flickerLogo();
});

</script>
</body>
</html>