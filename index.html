<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>OreStellar</title>

<!-- Google Font: Orbitron -->
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&display=swap" rel="stylesheet">

<!-- LZString for URL compression (share) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>

<style>
/* ================== BASE ================== */
:root{
  --neon: #ffffff;
  --bg: #000;
  --panel: rgba(20,20,20,0.92);
  --mono: 'Share Tech Mono', monospace;
  --orbitron: 'Orbitron', sans-serif;
}
html,body{margin:0;padding:0;height:100%;background:var(--bg);font-family:monospace;color:#fff;overflow:hidden;}
/* star canvas sits at z=0 and pointer-events none so overlay works */
canvas#starfield {
  position: fixed;
  top: 0;
  left: 0;
  z-index: 0;
  pointer-events: none;
}

/* ================== LAYOUT ================== */
.container-wrapper{
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  min-height:100vh;
  gap:20px;
  padding:20px;
  z-index:2;
  position:relative;
}

/* ================== LOGO ================== */
#myHeader{
  display:flex;
  justify-content:center;
  align-items:center;
  flex-direction:column;
  text-align:center;
  width:100%;
  max-width:650px;
  margin-bottom:30px;
  cursor:pointer;
  z-index:3;
}
#logoText{display:inline;font-family:var(--orbitron);font-weight:700;font-size:4.5rem;letter-spacing:0;color:rgba(255,255,255,0.1);transform:skewX(-8deg);}
#logoText span{display:inline;color:rgba(255,255,255,0.1);text-shadow:none;}

@keyframes softGlow {
  0%,100% { text-shadow: 0 0 5px #fff; color: rgba(255,255,255,0.75); }
  50% { text-shadow: 0 0 15px #fff; color: rgba(255,255,255,1); }
}

@keyframes flickerRapid {
  0%,20%,40%,60%,80%,100% { color: rgba(255,255,255,1); text-shadow: 0 0 10px #fff; }
  10%,30%,50%,70%,90% { color: rgba(255,255,255,0.1); text-shadow: none; }
}

@keyframes flickerQuick {
  0%,50%,100% { color: rgba(255,255,255,0.1); text-shadow: none; }
  25%,75% { color: rgba(255,255,255,1); text-shadow: 0 0 10px #fff; }
}



/* ================== MAIN PANEL ================== */
.main-container{
  width:650px;
  max-width:92%;
  padding:30px;
  display:flex;
  flex-direction:column;
  justify-content:center;
  align-items:center;
  background-color:var(--panel);
  border-radius:15px;
  z-index:2;
  box-shadow:0 6px 24px rgba(0,0,0,0.6);
}

/* header above textarea */
#inventoryHeader{
  font-family:var(--orbitron);
  font-weight:700;
  color:#fff;
  text-shadow:0 0 8px #fff,0 0 16px #fff,0 0 24px var(--neon);
  margin:0 0 12px 0;
  padding-bottom:6px;
}

/* textarea styling — filler smaller & greyed */
textarea#message{
  display:block;
  margin:0 auto;
  width:92%;
  font-size:14px;
  color:#bfbfbf; /* filler color until user edits */
  background-color: rgba(17,17,17,0.97);
  padding:14px;
  border-radius:10px;
  resize:vertical;
  border:1px solid #333;
  text-align:left;
  font-family:var(--mono);
  box-shadow: inset 0 0 6px #111;
  line-height:1.35;
  min-height:130px;
}
textarea#message.small-filler { font-size:13px; color:#9a9a9a; } /* smaller, greyed filler */

textarea#message:focus{
  outline:none;
  border-color:#fff;
  box-shadow:inset 0 0 15px #fff,0 0 25px #fff;
  color:#e6e6e6; /* actual typing color */
}

/* ================== BUTTONS ================== */
.actionButton{
  margin-top:15px;
  background:linear-gradient(145deg,#161616,#242424);
  color:#fff;
  border:2px solid #ccc;
  border-radius:10px;
  padding:12px 26px;
  font-weight:bold;
  font-family:var(--orbitron);
  cursor:pointer;
  position:relative;
  overflow:hidden;
  text-shadow:0 0 2px #fff;
  box-shadow:0 0 6px #ffffff33,0 0 12px #ffffff11 inset;
  transition:all 0.25s ease;
}
.actionButton:disabled{opacity:0.45;cursor:not-allowed;}

/* ================== CONTRACT / SUMMARY / PRICELIST ================== */
.contracts-wrapper{display:flex;justify-content:center;align-items:flex-start;gap:15px;flex-wrap:wrap;width:100%;}

/* contract images */
.total-cost-container{
  width:630px;height:418px;background-size:contain;background-position:center;background-repeat:no-repeat;position:relative;border-radius:15px;box-shadow:0 4px 8px rgba(0,0,0,0.5);display:none;
}
#leftContainer{background-image:url('https://raw.githubusercontent.com/OreStellar/Orestellar.github.io/refs/heads/main/images/Contract1.png');display:none;}
#totalCostContainer{background-image:url('https://raw.githubusercontent.com/OreStellar/Orestellar.github.io/refs/heads/main/images/Contract2.png');display:none;position:relative;}
#totalCostText{position:absolute;top:18px;right:20px;color:var(--neon);font-family:var(--mono);font-weight:bold;font-size:18px;text-shadow:0 0 6px var(--neon),0 0 12px var(--neon);cursor:pointer;}

/* price tab: Z with short horizontal line */
#priceTab{
  position:fixed;top:22vh;right:18px;width:48px;height:48px;border-radius:10px;background:var(--neon);color:#000;display:flex;justify-content:center;align-items:center;font-weight:700;font-size:20px;cursor:pointer;box-shadow:0 0 12px var(--neon),0 0 30px var(--neon) inset;z-index:30;transition:transform 0.18s ease;
  font-family:var(--orbitron);
}
#priceTab::before{ content:"\005A"; position:absolute; top:7px; font-size:28px; }
#priceTab::after{ content:""; position:absolute; top:22px; width:18px; height:2px; background:#000; }

/* floating price list */
#priceListContainer{
  position:fixed;top:18vh;right:78px;width:360px;max-height:72vh;overflow-y:auto;background:rgba(0,0,0,0.95);border:1px solid var(--neon);padding:12px;border-radius:10px;display:none;box-shadow:0 0 22px var(--neon);z-index:29;font-family:var(--mono);color:var(--neon);
}
#priceListContainer table{width:100%;border-collapse:collapse;}
#priceListContainer th,#priceListContainer td{padding:6px 8px;border-bottom:1px solid rgba(0,255,0,0.06);font-size:13px;text-align:left;}
#priceListContainer th{font-weight:700;color:var(--neon);}

/* summary container */
.summary-container{
  display:none;flex-direction:column;align-items:stretch;justify-content:flex-start;font-family:var(--mono);font-size:14px;line-height:1.4;color:var(--neon);background:rgba(0,10,0,0.95);border:2px solid var(--neon);border-radius:12px;padding:16px 20px;min-width:420px;max-width:520px;max-height:72vh;overflow-y:auto;backdrop-filter:blur(6px);box-shadow:0 0 18px rgba(0,255,0,0.18);z-index:3;
}
.summary-container::-webkit-scrollbar{width:8px;}
.summary-container::-webkit-scrollbar-thumb{background:var(--neon);border-radius:6px;box-shadow:0 0 10px var(--neon);}

.summary-table{width:100%;border-collapse:collapse;table-layout:fixed;}
.summary-table th, .summary-table td {padding:8px 10px;border-bottom:1px solid rgba(0,255,0,0.03);font-size:13px;white-space:nowrap;}
.summary-table th:nth-child(1), .summary-table td:nth-child(1){text-align:left;}
/* align numeric columns to the right */
.summary-table td.price, .summary-table td.quantity, .summary-table td.total-column {text-align:right;font-variant-numeric:tabular-nums;}
/* header numeric alignment: make headers match columns (right) */
.summary-table th{ text-align:right; color:var(--neon); text-shadow:0 0 6px var(--neon); border-bottom:1px solid rgba(0,255,0,0.1); }
.summary-table th:first-child{ text-align:left; } /* Name header left */
.summary-table tr.unrecognized td {color:#ff6666;font-weight:700;text-shadow:0 0 8px #ff5555;}
.summary-total td{border-top:2px solid rgba(0,255,0,0.18);font-weight:700;padding-top:10px; text-align:right;}

/* small responsive tweaks */
@media (max-width:720px){
  #priceListContainer{ right:10px; width:320px; max-height:50vh; }
  .main-container{padding:20px;}
  #logoText{font-size:3.2rem;}
}


</style>
</head>
<body data-show-inventory="true">

<!-- MAIN LAYOUT -->
<canvas id="starfield"></canvas>

<div class="container-wrapper" id="appRoot">
  <header id="myHeader" title="Return home">
    <h1 id="logoText"><span id="ore">Ore</span><span id="stellar">Stellar</span></h1>
  </header>

  <div class="main-container" id="inventoryContainer" role="region">
    <h3 id="inventoryHeader">Paste Your Inventory Below</h3>

    <!-- initial filler text is greyed and smaller -->
    <textarea id="message" class="small-filler" rows="8" >
Compressed Ytirium	1304752
Compressed Gneiss	166047
Obsidian Ochre	8603
Eifyrium	8242
Compressed Dark Ochre	5086
Compressed Jet Ochre	3750
Compressed Prize Mordunium	998781
Pellucid Crokite	2912
Compressed Ducinium	4985
    </textarea>

    <button id="submitButton" class="actionButton" disabled>Submit</button>
  </div>

  <div class="contracts-wrapper">
    <div id="leftContainer" class="total-cost-container"></div>
    <div id="summaryContainer" class="summary-container"></div>
    <div id="totalCostContainer" class="total-cost-container">
      <div id="totalCostText">0 ISK</div>
    </div>
  </div>
<div id="priceTab" title="Open price list" role="button"></div>
<div id="priceListContainer"></div>

  <button id="shareButton" class="actionButton" style="display:none;margin-top:14px;">Share Summary</button>
</div>

<script>
const logoText = document.getElementById('logoText');
const ore = document.getElementById('ore');
const stellar = document.getElementById('stellar');
/* ====================== STARFIELD ====================== */
const canvas = document.getElementById('starfield');
const ctx = canvas.getContext('2d');

let stars = [];
const clusterCount = 25; // your cluster count

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}

function createStars() {
  stars = [];
  const centers = [];
  for (let i = 0; i < clusterCount; i++) {
    centers.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height });
  }

  const total = Math.max(500, Math.floor(canvas.width * canvas.height / 1000));
  for (let i = 0; i < total; i++) {
    let x, y;
    if (Math.random() < 0.6) {
      const c = centers[Math.floor(Math.random() * centers.length)];
      const r = Math.random() * 140;
      const a = Math.random() * Math.PI * 2;
      x = c.x + r * Math.cos(a);
      y = c.y + r * Math.sin(a);
    } else {
      x = Math.random() * canvas.width;
      y = Math.random() * canvas.height;
    }

    const r = Math.random();
    let color = '#ffffff';
    if (r < 0.005) color = '#ff0000';
    else if (r < 0.025) color = '#ffb6c1';
    else if (r < 0.055) color = '#ffff99';

    stars.push({
      x, y,
      size: Math.random() * 1.6 + 0.2,
      color,
      baseAlpha: 0.7 + Math.random() * 0.25,
      isBright: false,
      brightStart: 0,
      brightEnd: 0
    });
  }
}

// draw stars
function drawStars() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  const now = performance.now();
  for (const s of stars) {
    let alpha = s.baseAlpha;
    if (s.isBright && now >= s.brightStart && now <= s.brightEnd) {
      alpha = 1;
    }
    ctx.globalAlpha = alpha;
    ctx.fillStyle = s.color;
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

// animate stars (twinkle)
function animateStars() {
  const now = performance.now();
  for (const s of stars) {
    if (Math.random() < 0.001 && !s.isBright) {
      s.isBright = true;
      s.brightStart = now;
      s.brightEnd = now + 1500 + Math.random() * 3000; // twinkle duration
    } else if (s.isBright && now > s.brightEnd) {
      s.isBright = false;
    }
  }
  drawStars();
  requestAnimationFrame(animateStars);
}

// initial setup
window.addEventListener('load', () => {
  resizeCanvas();
  createStars();
  drawStars();
  animateStars(); // start twinkle loop
});

// handle resizing
window.addEventListener('resize', () => {
  resizeCanvas();
  createStars();
  drawStars();
});


/* ====================== LOGO FLICKER SEQUENCE ====================== */
/* single setLogoState used by flicker sequence */
function setLogoState(color, shadow) {
  ore.style.color = color;
  stellar.style.color = color;
  ore.style.textShadow = shadow || 'none';
  stellar.style.textShadow = shadow || 'none';
  // also apply to the grouped logoText to ensure consistent look
  logoText.style.color = color;
  logoText.style.textShadow = shadow || 'none';
}

/* Clicking the header resets to base view */
document.getElementById('myHeader').addEventListener('click', () => {
  window.location.href = window.location.origin + window.location.pathname;
});

function flickerLogo() {
  const steps = [
    // 1. Initial dim (1.2s)
    { color: 'rgba(220,220,220,0.15)', shadow: 'none', delay: 0 },

    // 2. First flicker (60ms)
    { color: '#dcdcdc', shadow: '0 0 10px #bfbfbf, 0 0 18px #bfbfbf', delay: 1200 },
    { color: 'rgba(220,220,220,0.15)', shadow: 'none', delay: 1260 },

    // 3. Short dim (0.3s)
    { color: 'rgba(220,220,220,0.15)', shadow: 'none', delay: 1560 },

    // 4. Second flicker (60ms)
    { color: '#dcdcdc', shadow: '0 0 10px #bfbfbf, 0 0 18px #bfbfbf', delay: 1560 },
    { color: 'rgba(220,220,220,0.15)', shadow: 'none', delay: 1620 },

    // 5. Dim for 0.9s
    { color: 'rgba(220,220,220,0.15)', shadow: 'none', delay: 1620 },
    // 6. Final flash (40ms)
    { color: '#dcdcdc', shadow: '0 0 12px #bfbfbf, 0 0 24px #bfbfbf', delay: 2520 },
    { color: 'rgba(220,220,220,0.15)', shadow: 'none', delay: 2560 },
  ];

  steps.forEach(step => {
    setTimeout(() => {
      ore.style.color = step.color;
      stellar.style.color = step.color;
      logoText.style.color = step.color;
      ore.style.textShadow = step.shadow;
      stellar.style.textShadow = step.shadow;
      logoText.style.textShadow = step.shadow;
    }, step.delay);
  });

  // 7. Begin steady glow forever
  setTimeout(() => {
    const glowAnim = 'softGlow 6s infinite';
    logoText.style.animation = glowAnim;
    ore.style.animation = glowAnim;
    stellar.style.animation = glowAnim;
  }, 2560); // after last dim
}
const CSV_URL = 'https://raw.githubusercontent.com/OreStellar/Orestellar.github.io/main/data/prices.csv';
// RAW buy price is always column 10
const RAW_PRICE_COL = 10;

// Map base ores to their variants
const oreVariantMap = {
  "Dark Ochre": [
    "Onyx Ochre",
    "Obsidian Ochre",
    "Jet Ochre",
    "Charcoal Ochre"
  ]
};

// Build reverse map so each variant points to its base
const variantToBase = {};
for (const [base, variants] of Object.entries(oreVariantMap)) {
  for (const variant of variants) {
    variantToBase[normalizeName(variant)] = normalizeName(base);
  }
}

// Storage
let priceList = {};
let canonicalNames = {};

// fetch and parse CSV
async function fetchPrices() {
  try {
    const res = await fetch(CSV_URL);
    const txt = await res.text();
    const lines = txt.split(/\r?\n/).map(l => l.trim()).filter(l => l !== '');
    if (lines.length < 2) return;

    for (let i = 1; i < lines.length; i++) {
      const cols = splitCsvLine(lines[i]);
      if (cols.length <= RAW_PRICE_COL) continue;
      const name = (cols[0] || '').trim();
      if (!name) continue;
      if (/compressed/i.test(name)) continue;

      let suggestedRaw = cols[RAW_PRICE_COL].trim();
      let suggested = parseNumberSafe(suggestedRaw);
      if (!isFinite(suggested)) continue;

      const normalized = normalizeName(name);
      priceList[normalized] = suggested;
      canonicalNames[normalized] = name;

      // Handle variants mapping
      if (variantToBase[normalized]) {
        const baseNormalized = variantToBase[normalized];
        // optional: copy base price to variant if needed
        // priceList[normalized] = priceList[baseNormalized] || suggested;
      }
    }

  } catch (e) {
    console.error("Failed to fetch prices:", e);
  }
}
// Parse header robustly
const headerCols = lines[0].split(',').map(h => h.trim().toLowerCase());

// Always use the second-to-last column for prices
let suggestedIdx = headerCols.length - 2;

    // parse rows
    priceList = {};
    canonicalNames = {};
    for(let i=1;i<lines.length;i++){
      const cols = splitCsvLine(lines[i]);
      if(cols.length < 2) continue;
      const name = (cols[0] || '').trim();
      if(!name) continue;
      // skip compressed variants for price list (we'll still parse them in inventory)
      if(/compressed/i.test(name)) continue;

      // get suggested value if present
      let suggestedRaw = undefined;
      if(suggestedIdx >= 0 && suggestedIdx < cols.length){
        suggestedRaw = cols[suggestedIdx].trim();
      }
      // try parse
      let suggested = parseNumberSafe(suggestedRaw);

      const headerText = headerCols[suggestedIdx] || '';
      // Compute price to store as baseCSVPrice (we store raw CSV suggested; final displayed price may be multiplied)
      if(!isFinite(suggested)) {
        // try fallback: maybe price is second-to-last column as the dataset sometimes uses that
        const alt = cols[cols.length-2];
        suggested = parseNumberSafe(alt);
      }
      if(!isFinite(suggested)) continue;

      // Normalized key
      const normalized = normalizeName(name);
    priceList[normalized] = suggested; // just store the CSV value directly
            canonicalNames[normalized] = name;
}
    
function buildPriceGrouping() {
  const groupedPrices = {};

  // Iterate base -> variants
  for (const [base, variants] of Object.entries(oreVariantMap)) {
    groupedPrices[base] = [];

// Push each variant that exists in the priceList
variants.forEach(v => {
  const normalized = normalizeName(v);
  if (priceList[normalized]) {
    groupedPrices[base].push({
      name: canonicalNames[normalized],
      price: priceList[normalized]  // just the number now
    });
  }
});

  }

  return groupedPrices;
}

async function fetchPrices() {
  try {
    // Usage
    const groupedOrePrices = buildPriceGrouping();
    console.log(groupedOrePrices);

    // Build base names list (all non-compressed canonical names)
    baseNames = Object.values(canonicalNames).slice(); // display names

    // We'll normalize base candidate tokens to allow matching
    // Build oreEntries for inventory matching: prefer longer multi-word entries first
    oreEntries = Object.keys(canonicalNames).map(k => ({ key: k, tokens: k.split(/\s+/).length, length: k.length }));
    oreEntries.sort((a,b) => (b.tokens - a.tokens) || (b.length - a.length));

    // Precompute a map of base -> variants for price list grouping (non-compressed)
    buildPriceGrouping();

    // Fill the floating price list UI
    fillPriceList();

  } catch(err) {
    console.error('fetchPrices error', err);
  }
}

window.addEventListener('load', fetchPrices);

/* helper: split csv line but keep commas in quoted fields -- simple robust split */
function splitCsvLine(line){
  // simple parser for CSV without external libs
  const out = [];
  let cur = '', inQuotes = false;
  for(let i=0;i<line.length;i++){
    const ch = line[i];
    if(ch === '"' ){
      inQuotes = !inQuotes;
      continue;
    }
    if(ch === ',' && !inQuotes){
      out.push(cur);
      cur = '';
      continue;
    }
    cur += ch;
  }
  out.push(cur);
  return out;
}

/* safe parse for numbers with commas and currency characters */
function parseNumberSafe(str){
  if(str === undefined || str === null) return NaN;
  const s = String(str).replace(/[^\d.\-]/g,'').trim();
  if(s === '') return NaN;
  const n = parseFloat(s);
  return isFinite(n) ? n : NaN;
}

/* normalize names for keys: lowercase, single spaces, trim */
function normalizeName(name){
  return (name || '').toString().toLowerCase().replace(/\s+/g,' ').trim();
}
function roundDownFlexible(n) {
  if (n >= 1000) return Math.floor(n / 100) * 100;
  if (n >= 100)  return Math.floor(n / 10) * 10;
  if (n >= 10)   return Math.floor(n / 10) * 10;
  if (n >= 1)    return Math.floor(n);
  if (n > 0)     return Math.floor(n * 1) / 1;
  return n;
}

/* ====================== PRICE GROUPING (for the floating list) ====================== */
/*
  We'll group by "base" detection:
  - For each canonical name, the "base" is chosen as the last word by default, BUT we try to match
    against any other canonical non-compressed name if that appears as a whole word (case-insensitive)
    inside this variant's name. This avoids 'Augmented Eifyrium' -> base 'Eifyrium'.
*/
let groupedPriceMap = {}; // baseDisplayName -> array of {name, priceToDisplay}

function buildPriceGrouping(){
  groupedPriceMap = {};

  // prepare an array of candidate base names (display form) and normalized versions
  const candidateBases = Object.values(canonicalNames).slice(); // display names
  const normalizedBases = candidateBases.map(b => normalizeName(b));

  // iterate through each canonical name
  Object.keys(canonicalNames).forEach(normKey => {
    const display = canonicalNames[normKey];
    const lower = normalizeName(display);

    // find a matching base among candidateBases that appears in the name as a whole word (prefer exact matches)
    let chosenBase = null;
    // prefer base that equals the last word (most common)
    const lastWord = lower.split(' ').slice(-1)[0];
    for(let i=0;i<candidateBases.length;i++){
      if(normalizeName(candidateBases[i]) === lastWord){
        chosenBase = candidateBases[i];
        break;
      }
    }
    // fallback: find any base that appears in the name
    if(!chosenBase){
      for(let i=0;i<candidateBases.length;i++){
        const bNorm = normalizedBases[i];
        // whole-word match using regex boundaries
        const re = new RegExp('\\b' + escapeRegex(bNorm) + '\\b','i');
        if(re.test(lower)){
          chosenBase = candidateBases[i];
          break;
        }
      }
    }
    // final fallback: the display itself
    if(!chosenBase) chosenBase = display;

const entry = priceList[normKey];
if (entry === undefined) return; // handle missing gracefully

let priceToShow = entry; // CSV value directly

if (!groupedPriceMap[chosenBase]) groupedPriceMap[chosenBase] = [];
groupedPriceMap[chosenBase].push({ name: display, price: priceToShow });


  });
}
/* simple regex escape */
function escapeRegex(s){ return s.replace(/[.*+?^${}()|[\]\\]/g,'\\$&'); }

function fillPriceList(){
  // produce a table grouped by base (alphabetical by base)
  const bases = Object.keys(groupedPriceMap).sort((a,b)=> a.localeCompare(b));
  let html = '<table><thead><tr><th>Ore</th><th>OreStellar Buy Price</th></tr></thead><tbody>';
  for(const base of bases){
    // show the variants sorted
    const variants = groupedPriceMap[base];
    variants.forEach((v, idx) => {
      // if variant name equals base, show normally; else indent with - prefix
      const displayName = (idx===0 && normalizeName(variants[0].name) === normalizeName(base)) ? variants[0].name : v.name;
      const prefix = (displayName === base) ? '' : '&nbsp;&nbsp;- ';
      const roundedPrice = roundDownFlexible(v.price);
      html += `<tr><td>${prefix}${escapeHtml(displayName)}</td><td style="text-align:right">${formatNumberDecimal(roundedPrice)}</td></tr>`;
    });
  }
  html += '</tbody></table>';
  priceListContainer.innerHTML = html;
}

/* number formatting with two decimals when fractional */
function formatNumberDecimal(n){
  if(n === null || n === undefined || isNaN(n)) return '-';
  // if n is effectively integer, show as integer, else show 2 decimals
  if(Math.abs(Math.round(n) - n) < 0.005) return Math.round(n).toLocaleString();
  return n.toFixed(2).toLocaleString();
}

/* ====================== PRICE TAB TOGGLE ====================== */
const priceTab = document.getElementById('priceTab');
const priceListContainer = document.getElementById('priceListContainer');

priceTab.addEventListener('click', () => {
  // If hidden, show it and make sure it’s updated
  if (priceListContainer.style.display !== 'block') {
    if (Object.keys(groupedPriceMap).length === 0) {
      buildPriceGrouping();
      fillPriceList();
    }
    priceListContainer.style.display = 'block';
  } else {
    // Otherwise, hide it
    priceListContainer.style.display = 'none';
  }
});
/* ====================== INVENTORY TEXTAREA BEHAVIOR ====================== */
/* Filler text is present on load. We want:
   - smaller, greyed filler displayed initially
   - on first user focus, clear the filler and set normal typing color
   - while filler remains, Submit button disabled
*/

const messageBox = document.getElementById('message');
const submitButton = document.getElementById('submitButton');
let userHasEdited = false;

// ensure initial filler present and small-filler style
if(messageBox.value.trim() === ''){
  messageBox.classList.add('small-filler');
} else {
  // if there is prefilled text (we intentionally placed filler), keep small-filler until user focuses
  messageBox.classList.add('small-filler');
}

// on input enable submit if non-empty and not filler status
messageBox.addEventListener('input', ()=>{
  const txt = messageBox.value.trim();
  // if user has started typing (non-whitespace) we consider edited
  if(txt.length > 0 && messageBox.classList.contains('small-filler') === false) {
    userHasEdited = true;
  }
  // enable submit only if user actually edited and not empty
  submitButton.disabled = !(userHasEdited && txt.length > 0);
});

// On focus, if small-filler present, clear it for first edit
messageBox.addEventListener('focus', ()=>{
  if(messageBox.classList.contains('small-filler')){
    messageBox.value = '';
    messageBox.classList.remove('small-filler');
    messageBox.style.color = '#e6e6e6';
    userHasEdited = true;
    submitButton.disabled = true; // keep disabled until user types something
  }
});

/* Also on blur, if empty, restore filler text (optional) - but we won't restore automatically to avoid confusion */
messageBox.addEventListener('blur', ()=>{
  if(!messageBox.value.trim()){
    // keep it empty but maintain small-filler class so it's visually empty; user will see blank field
    messageBox.classList.add('small-filler');
    messageBox.style.color = '#bfbfbf';
    userHasEdited = false;
    submitButton.disabled = true;
  }
});

/* ====================== PARSING INVENTORY & SUMMARY ====================== */
/*
  parseInventoryText: returns array of items:
    { name: displayName, qty: integer, price: number (per unit, from priceList), total: qty*price, unrecognized:bool }
  Behavior:
    - tries to find the best matching ore name from oreEntries (longest names tried first)
    - extracts first integer quantity found (handles commas)
    - looks up the canonical price; if missing, price = 0 and unrecognized style shown
*/
function parseInventoryText(text){
  const lines = text.split(/\r?\n/).map(l => l.trim()).filter(l => l !== '');
  const result = [];

  for(const rawLine of lines){
    // remove obvious 'compressed' prefix for matching but keep display of original
    const lineNoCompressed = rawLine.replace(/compressed\s+/i, '').trim();
    const lowerLine = lineNoCompressed.toLowerCase();

    // find best matching ore entry (oreEntries are normalized keys)
    let foundKey = null;
    for(const entry of oreEntries){
      const key = entry.key; // normalized key like 'eifyrium' or 'glazed hedbergite'
      // create a regex for whole word match sequence of tokens to avoid partial wrong matches
      // allow presence of punctuation around
      const re = new RegExp('\\b' + escapeRegex(key) + '\\b','i');
      if(re.test(lowerLine)){
        foundKey = key;
        break;
      }
    }

    // extract quantity (first big integer-looking token with commas)
    let qty = 0;
    const qtyMatch = rawLine.match(/([\d,]{1,})/);
    if(qtyMatch){
      qty = parseInt(qtyMatch[1].replace(/,/g,''), 10) || 0;
    } else {
      // try to find integers that might be after the name
      const alt = lineNoCompressed.match(/\b(\d{1,})\b/);
      qty = alt ? parseInt(alt[1],10) : 0;
    }
if(foundKey){
  const canonical = canonicalNames[foundKey] || foundKey;
  const perUnit = priceList[foundKey] || 0;  // just the number
  const total = perUnit * qty;
  result.push({ name: canonical, qty, price: perUnit, total, unrecognized:false });
} else {
  // not found: include as unrecognized with original display trimmed
  const guessName = (lineNoCompressed.split(/\s+/).slice(0,4).join(' ')).trim();
  result.push({ name: guessName, qty, price:0, total:0, unrecognized:true });
}


  return result;
}

/* RENDER SUMMARY: produce table with headers that align with columns */
const summaryContainer = document.getElementById('summaryContainer');

function renderSummary(parsedItems){
  // compute grand total
  let grandTotal = 0;
  parsedItems.forEach(it => { grandTotal += (it.total || 0); });

  // Build table
  let html = '<table class="summary-table" role="table"><thead><tr>' +
    '<th>Name</th>' +
    '<th>Price</th>' +  // show price (right aligned)
    '<th>Quantity</th>' +
    '<th>Total</th>' +
    '</tr></thead><tbody>';

 parsedItems.forEach(it => {
  if(it.unrecognized){
    const truncated = (it.name || '').slice(0,28) + (it.name && it.name.length > 28 ? '…' : '');
    html += `<tr class="unrecognized"><td>${escapeHtml(truncated)}</td><td class="price">---</td><td class="quantity">---</td><td class="total-column">Unrecognized</td></tr>`;
  } else {
    const roundedPrice = roundDownFlexible(it.price);
    const roundedTotal = roundDownFlexible(it.total);
    
    html += `<tr><td>${escapeHtml(it.name)}</td>` +
            `<td class="price">${formatNumberDecimal(roundedPrice)}</td>` +
            `<td class="quantity">${formatNumberInteger(it.qty)}</td>` +
            `<td class="total-column">${formatNumberDecimal(roundedTotal)}</td></tr>`;
  }
});


  html += `<tr class="summary-total"><td colspan="3" style="text-align:left">Total</td><td id="summaryTotal">${formatNumberDecimal(grandTotal)}</td></tr>`;
  html += '</tbody></table>';

  summaryContainer.innerHTML = html;
  summaryContainer.style.display = 'flex';

  // show contract containers
  document.getElementById('leftContainer').style.display = 'block';
  document.getElementById('totalCostContainer').style.display = 'flex';
  document.getElementById('shareButton').style.display = 'inline-block';

  // update top-right contract total copyable
  const totalText = document.getElementById('totalCostText');
  totalText.innerText = formatNumberDecimal(grandTotal) + ' ISK';
  makeCopyable(totalText);

  // make the summary total copyable
  const sumEl = document.getElementById('summaryTotal');
  if(sumEl) makeCopyable(sumEl);

  attachSorting(summaryContainer);
}

/* helpers for number formatting */
function formatNumberInteger(n){
  if(n === null || n === undefined) return '-';
  return (typeof n === 'number' ? Math.round(n) : n).toLocaleString();
}
function formatNumberDecimal(n){
  if(n === null || n === undefined) return '-';
  if(typeof n !== 'number') return String(n);
  // show no decimals when integer, else two decimals
  if(Math.abs(Math.round(n) - n) < 0.005) return Math.round(n).toLocaleString();
  return n.toFixed(2).toLocaleString();
}

function makeCopyable(el){
  el.style.cursor = 'pointer';
  el.addEventListener('click', async ()=>{
    try {
      const text = el.innerText.replace(/[^\d\.\,]/g,'');
      await navigator.clipboard.writeText(text);
      const orig = el.innerText;
      el.innerText = 'Copied';
      setTimeout(()=> el.innerText = orig, 1200);
    } catch(e){
      // ignore
    }
  });
}

/* safe escape for HTML */
function escapeHtml(s){
  if(s===null || s===undefined) return '';
  return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
}

/* ====================== SORTING FOR SUMMARY ====================== */
function attachSorting(container){
  const table = container.querySelector('table');
  if(!table) return;
  const headers = table.querySelectorAll('th');
  headers.forEach((header, index) => {
    header.style.cursor = 'pointer';
    header.addEventListener('click', ()=>{
      const tbody = table.querySelector('tbody');
      const rows = Array.from(tbody.querySelectorAll('tr')).filter(r => !r.classList.contains('summary-total'));
      const totalRow = tbody.querySelector('.summary-total');
      const ascending = !header.classList.contains('sorted-asc');
      headers.forEach(h=>h.classList.remove('sorted','sorted-asc','sorted-desc'));
      header.classList.add('sorted');
      header.classList.toggle('sorted-asc', ascending);
      header.classList.toggle('sorted-desc', !ascending);

      rows.sort((a,b)=>{
        // unrecognized to bottom
        if(a.classList.contains('unrecognized') && !b.classList.contains('unrecognized')) return 1;
        if(b.classList.contains('unrecognized') && !a.classList.contains('unrecognized')) return -1;

        if(index === 0){
          // name column: alphabetical
          return ascending ? a.children[index].innerText.localeCompare(b.children[index].innerText)
                           : b.children[index].innerText.localeCompare(a.children[index].innerText);
        } else {
          // numeric columns
          const A = parseFloat(a.children[index].innerText.replace(/[^\d.\-]/g,'')) || 0;
          const B = parseFloat(b.children[index].innerText.replace(/[^\d.\-]/g,'')) || 0;
          return ascending ? A - B : B - A;
        }
      });

      rows.forEach(r => tbody.appendChild(r));
      if(totalRow) tbody.appendChild(totalRow);
    });
  });
}

/* ====================== SUBMIT / SHARE LOGIC ====================== */
const shareButton = document.getElementById('shareButton');

submitButton.addEventListener('click', ()=>{
  // double-check we have user content
  const txt = messageBox.value.trim();
  if(!txt) return;
  const parsed = parseInventoryText(txt);
  renderSummary(parsed);
  window.scrollTo({ top: 0, behavior:'smooth'});
  // HIDE INVENTORY AND SUBMIT
  document.getElementById('inventoryContainer').style.display = 'none';
  submitButton.style.display = 'none';
});

shareButton.addEventListener('click', async ()=>{
  const msg = messageBox.value.trim();
  if(!msg) return;
  const compressed = LZString.compressToEncodedURIComponent(msg);
  const url = `${location.origin}${location.pathname}?s=${compressed}`;
  try {
    await navigator.clipboard.writeText(url);
    const orig = shareButton.innerText;
    shareButton.innerText = 'Copied';
    setTimeout(()=> shareButton.innerText = orig, 1400);
  } catch(e){
    alert('Failed to copy URL.');
  }
});

/* Auto-load from URL param ?s= (shared view) */
window.addEventListener('load', async () => {
    // fetch prices first
    await fetchPrices();

    // optionally start logo flicker
    flickerLogo();
}); // ✅ close both function block and addEventListener call


  // Check URL param
  const params = new URLSearchParams(window.location.search);
  const s = params.get('s');
  if(s){
    const text = LZString.decompressFromEncodedURIComponent(s);
    if(text){
      // populate message box with the text and render summary in shared view
      messageBox.value = text;
      userHasEdited = true;
      submitButton.disabled = false;
      const parsed = parseInventoryText(text);
      renderSummary(parsed);
      // show shared ledger style
      summaryContainer.classList.add('shared-ledger');
      // hide interactive controls visually
      document.querySelector('.main-container').style.display = 'none';
      document.getElementById('leftContainer').style.display = 'none';
      document.getElementById('totalCostContainer').style.display = 'none';
      shareButton.style.display = 'none';
      // keep price list hidden
      priceListContainer.style.display = 'none';
    }
  }

/* ====================== UTILITIES & INIT ====================== */
function buildPriceGroupingIfNeeded(){
  if(Object.keys(groupedPriceMap).length === 0) buildPriceGrouping();
}

function init(){
  // initial state: submit disabled until user edits
  submitButton.disabled = true;

  // populate price list (fetchPrices is already called on load)
}
init();

/* small helper: when entering numeric strings with commas, convert to number safely */
function parseIntSafeWithCommas(s){
  if(!s) return 0;
  const m = String(s).match(/[\d,]+/);
  if(!m) return 0;
  return parseInt(m[0].replace(/,/g,''),10) || 0;
}
</script>
</body>
</html>
